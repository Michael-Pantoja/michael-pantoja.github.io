<!DOCTYPE HTML>
<!--
	Twenty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>6 Degrees of NBA Players</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>	<!-- This adds tex -->
<link rel="stylesheet" href="../assets/css/main.css" />
<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>

	</head>
	<body class="index is-preload">
		<div id="page-wrapper">

			<!-- Header -->
			<header id="header" class="alt-article">
				<h1 id="logo"><a href="../index.html">Michael Pantoja</a></h1>
					<nav id="nav">
						<ul>
							<li><a href="https://github.com/Michael-Pantoja" class="icon brands circle fa-github"><span class="label">Github</span></a></li>
							<li><a href="https://www.linkedin.com/in/michael-pantoja-collasso-a271731ab/" class="icon brands circle fa-linkedin"><span class="label">LinkedIn</span></a></li>
							<li class="current"><a href="../index.html">Home</a></li>
							<li class="current"><a href="https://public.tableau.com/app/profile/michaelpantoja/vizzes">Visualizations</a></li>
							<li class="current"><a href="../portfolio.html">Portfolio</a></li>
							<li class="current"><a href="../contact.html">Contact</a></li>
						</ul>
					</nav>
			</header>

			<!-- Main -->
				<article id="main">

					<header class="special container">
						<span class="icon solid fa-project-diagram"></span>
						<br/>
						<h1 style = font-size:40px><strong>Six Degrees of NBA Players - A BFS Approach</strong></h1>
					</header>

					<!-- One -->
						<section class="wrapper style4 container" style="padding-top: 0em;">
							
							<!-- Content -->
								<div class="content">
									<section>

											<h2>I. Introduction</h2>

										<p> 
											Think of your favorite celebrity that has been in a movie. It is almost guranteed that through a web of mutual costars, there will always be a path that leads to Kevin Bacon.
											What's even more wild, is that you will probably find a connection that only needs 6 or less costars.
											Don't believe me, you can try it yourself by visiting <a href = 'https://oracleofbacon.org/'>The Oracle of Bacon</a>. 
											We'll go over the math in a bit, but I just wanted to introduce this website as a bit of a primer for what we are going to discuss, for it was this project 
											that prompted the idea of creating a similar application, but using only NBA Players.
										</p>
										<p>
											With this context, I created NBA Teams Apart (NBATA). NBATA is a simple web application in which you can select any two basketball players in professional history dating all the way 
											back to 1947, and you will find a connection between them through shared teammates. If you want to try it yourself, you can visit <a href="http://www.nbateamsapart.com/">NBATeamsApart.com</a>.
										</p>

										<center>
										<ul class="buttons">
									<li><a href="http://www.nbateamsapart.com/" class="button">NBA Teams Apart</a></li>
										</ul>
										</center>

									</section>
									<br>
									<section>

											<h2>II. Only Six Degrees, How?</h2>

										<p>
											It seems a bit remarkable that if you pick any two players in basketball history, that you will be able to find a chain of teammates that is pretty much always going to be
											less than 6 players. But why?
										</p>
										<p>
											The answer to this is related to <a href = "https://en.wikipedia.org/wiki/Graph_theory"> Graph Theory</a>. Graph theory is a methematical branch that deals with the way objects
											are related to each other. I'm not going to go into a ton of depth into this because it's a bit outside of the scope of this simple blog post, so instead we'll go through a 
											quick math exercise.
										</p>
										<p>
											Four years ago, there was a <a href = 'https://www.reddit.com/r/nba/comments/tc196a/guess_how_many_players_there_have_been_in_nba/'>Reddit post</a> that indicated that there have been 5,018 players that have played in the NBA. To keep numbers simple, let's say that there are now 
											6,000 players in the league since the time this post was made. A big jump but we like round numbers over here.
										</p>

										<center>							
										<p>
											\( T_p = 6000 \)
										</p>
										</center>
										<p>
											I feel like for some people, seeing this number is already making the claim that we can make a connection between two basketball players, a bit more believable.
											Let's continue. Now we're going to make the assumption that each player has 14 different teammates at a time. This is to assume that each NBA roster has 15 players.
										</p>
										<center>							
										<p>
											\( N_p = 14 \)
										</p>
										</center>
										<p>	
										<p>
											Now, it's reasonable to assume that not every team was created only through draft picks since the inception of the team. So, to go take into account teams being 
											traded, signed, and waived. Let's say that 7 players from each team have also been a part of a different team.
										</p>
										<center>							
										<p>
											\( N_t = 7 \)
										</p>
										</center>
										<p>
											This means that those 7 teammates that came from a different team have a connection with 14 different players. 
											Putting the pieces together, that means that any single player on a team \( P_c \) already has a network of 91 unique players. 
										</p>										<center>							
										<center>							
										<p>
											\( P_c = (N_p * N_t) - N_t \) <br>
											\( P_c = (14 * 7) - 7 \) <br>
											\( P_c = 91 \)
										</p>
										</center>
										<p>
											So with just one player and one connection, we get 91. What happens if we want to expand this into two connections. Well to keep it simple, we can just square the number 
											we calculated and get \( P_{c2} = 8,281 \). 8,281 players alraedy puts us above all NBA players in history. Of course the numbers don't explode that quickly when it comes
											to our example. There is a bit of overlap between players and teams and I don't think I need to clarify this but not all 6,000 players were active at the same time. 
											The point of this example was to show how quickly numbers can blow up. 
										</p>
										<p>
											This example has some backing though. Facebook did an in-depth analysis to determine what the average distance between users on Facebook was and the answer was 4.7. 
											A shockingly low number. If you want to read the entire paper, you can find it here, <a href = 'https://arxiv.org/abs/1111.4503'>The Anatomy of the Facebook Social Graph</a>
										</p>
									</section>

									<section>
										<h2>III. A Breadth First Search Approach</h2>
									</section>

									<p>
										The math is great and all but how exactly do we implement an algorithm to filter through every player, every team, and every connection to ensure that not only 
										do we get the correct answer, but we don't run a million calculations every single time. Enter Breadth-First Search (BFS).
									</p>
									<center>
									<img src = 'https://media.geeksforgeeks.org/wp-content/uploads/20240216084522/bfs-vs-dfs-(1).png'></img>
									</center>
									<br>
									<p>
										BFS is an algorithm that traverses nodes in a graph by exploring every neighbor at the current level before moving on to the next. 
										This is different from Depth-First Search (DFS), which follows a path as far as it can before backtracking.
										While both algorithms have their place, if the goal is to find the shortest path between two nodes, BFS is typically the better choice. 
										Because it explores all nodes at one “layer” before moving deeper, 
										the first time you reach a node you can be confident that you’ve found the shortest path to it. 
										With DFS, you would need to explore every possible path to guarantee the shortest one.
									</p>
									<p>
										Let's use an example with NBA context.
									</p>
									<p>
										Let's say we want to find the relationship between Stephen Curry (Player A) and Anthony Edwards (Player B).
									</p>
									<p>
										The first thing we need to do is get a list of all the teams that Steph Curry has played on in his career.
									</p>
									<center>
										<div style="text-align:center;">
											<table style="display:inline-table; width:auto; table-layout:auto; border-collapse:collapse;">

											  <thead>
												<tr>
												  <th style="padding:.55rem 1.25rem; border-bottom:1px solid rgba(0,0,0,.55); font-weight:600; text-align:left;">Team ID</th>
												  <th style="padding:.55rem 1.25rem; border-bottom:1px solid rgba(0,0,0,.55); font-weight:600; text-align:center;">Team Label</th>
												  <th style="padding:.55rem 1.25rem; border-bottom:1px solid rgba(0,0,0,.55); font-weight:600; text-align:right;">Season</th>
												</tr>
											  </thead>
											  <tbody>
												<tr>
												  <td style="padding:.45rem 1.25rem; text-align:right;">GSW10</td>
												  <td style="padding:.45rem 1.25rem; text-align:left;">Golden State Warriors</td>
												  <td style="padding:.45rem 1.25rem; text-align:center;">2009-10</td>
												</tr>
												<tr>
												  <td style="padding:.45rem 1.25rem; text-align:right;">GSW11</td>
												  <td style="padding:.45rem 1.25rem; text-align:left;">Golden State Warriors</td>
												  <td style="padding:.45rem 1.25rem; text-align:center;">2010-11</td>
												</tr>
												<tr>
												  <td style="padding:.45rem 1.25rem; text-align:right;">GSW12</td>
												  <td style="padding:.45rem 1.25rem; text-align:left;">Golden State Warriors</td>
												  <td style="padding:.45rem 1.25rem; text-align:center;">2011-12</td>
													
												  </tr>
												<tr>
												  <td style="padding:.45rem 1.25rem; text-align:left;">&hellip;</td>
												  <td style="padding:.45rem 1.25rem; text-align:center;">&hellip;</td>
												  <td style="padding:.45rem 1.25rem; text-align:right;">&hellip;</td>
												</tr>
												<tr>
												  <td style="padding:.45rem 1.25rem; text-align:right;">GSW25</td>
												  <td style="padding:.45rem 1.25rem; text-align:left;">Golden State Warriors</td>
												  <td style="padding:.45rem 1.25rem; text-align:center;">2024-25</td>
												</tr>
											  </tbody>
											</table>
											<div style="font-size:0.95rem; margin-bottom:.4rem;">
												<strong>Table 1.</strong> Stephen Curry Team History
											  </div>
										  </div>
									  </center>	
									  
									  <div>
										Now, what we can do is iterate through each team and then create a queue that has a list of all players from each team.
									  </div>

									  <center>
										<div style="text-align:center;">
											<table style="display:inline-table; width:auto; table-layout:auto; border-collapse:collapse;">

											  <thead>
												<tr>
													<th style="padding:.55rem 1.25rem; border-bottom:1px solid rgba(0,0,0,.55); font-weight:600; text-align:right;">Player ID</th>
													<th style="padding:.55rem 1.25rem; border-bottom:1px solid rgba(0,0,0,.55); font-weight:600; text-align:center;">Player Label</th>
												  <th style="padding:.55rem 1.25rem; border-bottom:1px solid rgba(0,0,0,.55); font-weight:600; text-align:left;">Team ID</th>
												</tr>
											  </thead>
											  <tbody>
												<tr>
													<td style="padding:.45rem 1.25rem; text-align:right;">azubuke01</td>
													<td style="padding:.45rem 1.25rem; text-align:center;">Kelenna Azubuike</td>
													<td style="padding:.45rem 1.25rem; text-align:left;">GSW10</td>
												</tr>
												<tr>
													<td style="padding:.45rem 1.25rem; text-align:right;">bellra01</td>
													<td style="padding:.45rem 1.25rem; text-align:center;">Raja Bell</td>
													<td style="padding:.45rem 1.25rem; text-align:left;">GSW10</td>
												</tr>
												<tr>
													<td style="padding:.45rem 1.25rem; text-align:right;">ellismo01</td>
													<td style="padding:.45rem 1.25rem; text-align:center;">Monta Ellis</td>
													<td style="padding:.45rem 1.25rem; text-align:left;">GSW10</td>
												</tr>
												<tr>
												  <td style="padding:.45rem 1.25rem; text-align:left;">&hellip;</td>
												  <td style="padding:.45rem 1.25rem; text-align:center;">&hellip;</td>
												  <td style="padding:.45rem 1.25rem; text-align:right;">&hellip;</td>
												</tr>
												<tr>
													<td style="padding:.45rem 1.25rem; text-align:right;">spencpa01</td>
													<td style="padding:.45rem 1.25rem; text-align:center;">Pat Spencer</td>
												  <td style="padding:.45rem 1.25rem; text-align:left;">GSW25</td>
												</tr>
											  </tbody>
											</table>
											<div style="font-size:0.95rem; margin-bottom:.4rem;">
												<strong>Table 2.</strong> Players from Steph Curry Teams
											  </div>
										  </div>
									  </center>	

									  <div>
										At this point, I also want to bring up another important aspect of DSA type problems and that are sets and dictionaries.
										As we iterate through each team and player, we are storing them in a set so we can know if we have already visited 
										a team or a player. This makes it so that we do not commit duplicate calculations or get stuck in an infinite loop.
									  </div>

									<center>							
										<p>
											\[ \text{Seen}_{\text{Teams}} = \{ \text{GSW}_{10}, \text{GSW}_{11}, \text{GSW}_{12}, \ldots, \text{GSW}_{25} \} \]
										</p>
									</center>
									<center>							
										<p>
											\[ \text{Seen}_{\text{Players}} = \{ \text{azubuke01}, \text{bellra01}, \text{ellismo01}, \ldots, \text{spencpa01} \} \]
										</p>
									</center>
									<br>
									<p>
										I also mentioned a queue earlier. For our first iteration, our queue is going to look the same as the SeenPlayers set. 
										That's because our queue is going to have every player from every team that Player A has played with.  
									</p>
									<center>							
										<p>
											\[ \text{queue} = \{ \text{azubuke01}, \text{bellra01}, \text{ellismo01}, \ldots, \text{spencpa01} \} \]
										</p>
									</center>
									<center>							
										<p>
											\[ \text{res} = 1\]
										</p>
									</center>
									<br>
									<p>
										The <code>res</code> simply represents which iteration or "step" we are on.
										From here, because we know who Player B is, we simply iterate through all players until we get a match.
										In this case, we are iterating through all of the names in the queue until we find Anthony Edwards (edwaran01).
										This is where things get interesting! Because we know that Anthony Edwards and Steph Curry never played together, 
										Anthony Edwards is not going to be in the queue. 
										So what we do now, is we repeat that same process of iterating through each teammate that a player has had in their career,
										with <strong>every single player in the queue</strong>. Steph Curry alone has played with 100+ different teammates.
										Imagine how many players are going to be in our <code>SeenPlayers</code> set once we iterate through all of those players 
										and figure out how many teammates all of those players have played with, combined. 
										Doing an example like this shows us just how quickly these numbers can explode.
										It also takes a bit of the magic away from it but that's okay!
									</p>
									<p>
										If you're curious to see what the link between Steph Curry and Anthony Edwards is, here's what my algorithm calculated.
									</p>
									<center>
										<img 
										  src="imgs/nta_01.png"
										  style="max-width:70%; height:auto; display:block; margin:0 auto;"
										  alt="NBA Teams Apart visualization"
										>
									  </center>
									<br>
									<section>
										<h2>IV. Thoughts</h2>
									</section>
									<p>
										I wanted to pop by and make a few notes.
										First of all, even though our algorithm said that the shortest bath between Curry and Ant is through the use of Donte,
										that does not mean that it's the <i>only</i> valid path. 
										To keep things optimized, the algorithm exits out of the iteration and returns the chain the moment it finds its first connection.
										As mentioned, this is because BFS will always return the shortest path between two objects.
										There is no need to keep iterating through names because we know for a fact that we alraedy have the shortest path.
										For example, we know Kyle Anderson also played for the Timberwolves alongside Anthony Edwards and he also played on the Warriors.
										Curry -> Anderson -> Edwards is a valid connection, but because it's the same length as the connection with Donte, it doesn't really matter.
									</p>


									<center>
										<ul class="buttons">
									<li><a href="../portfolio.html" class="button">Return to Portfolio</a></li>
										</ul>
										</center>


								</div>
						</section>

								</div>
							</div>
						</section>

				</article>

			<!-- Footer -->
				<footer id="footer">

					<ul class="icons">
						<li><a href="https://github.com/Michael-Pantoja" class="icon brands circle fa-github"><span class="label">Github</span></a></li>
						<li><a href="https://www.linkedin.com/in/michael-pantoja-collasso-a271731ab/" class="icon brands circle fa-linkedin"><span class="label">LinkedIn</span></a></li>
					</ul>
				</footer>


		</div>

		<!-- Scripts -->
		<script src="../assets/js/jquery.min.js"></script>
		<script src="../assets/js/jquery.scrollex.min.js"></script>
		<script src="../assets/js/jquery.scrolly.min.js"></script>
		<script src="../assets/js/browser.min.js"></script>
		<script src="../assets/js/breakpoints.min.js"></script>
		<script src="../assets/js/util.js"></script>
		<script src="../assets/js/main.js"></script>


	</body>
</html>